<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tunnel Runner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000010;
            color: #ffffff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            /* Prevent touch actions like scrolling on the page */
            touch-action: none;
        }
        canvas {
            background-color: #000010;
            display: block;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.7);
        }
        .ui-element {
            position: absolute;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            color: #00ffff;
        }
        #touch-controls {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 100;
            display: none; /* Hidden by default, shown via JS for touch devices */
        }
        .touch-button {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: rgba(0, 255, 255, 0.2);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
        }
        .touch-button:active {
            background-color: rgba(0, 255, 255, 0.5);
        }
        #touch-up { top: 0; left: 70px; }
        #touch-down { top: 140px; left: 70px; }
        #touch-left { top: 70px; left: 0; }
        #touch-right { top: 70px; left: 140px; }
    </style>
</head>
<body>

<div id="game-container" class="relative w-full h-full flex items-center justify-center">
    <canvas id="gameCanvas"></canvas>
    <div id="score" class="ui-element top-4 left-8 text-2xl">SCORE: 0</div>
    <div id="speed" class="ui-element top-4 right-8 text-2xl">SPEED: 1</div>
    
    <!-- On-screen controls for touch devices -->
    <div id="touch-controls">
        <div id="touch-up" class="touch-button">▲</div>
        <div id="touch-left" class="touch-button">◀</div>
        <div id="touch-right" class="touch-button">▶</div>
        <div id="touch-down" class="touch-button">▼</div>
    </div>

    <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-70 text-center p-4">
        <h1 class="text-6xl md:text-7xl mb-4 text-cyan-300">Tunnel Runner</h1>
        <p class="text-xl md:text-2xl mb-8">Survive as long as you can!</p>
        <p class="text-lg md:text-xl mb-2">Use WASD / Arrow Keys</p>
        <p class="text-lg md:text-xl mb-8">or On-Screen Controls</p>
        <button id="start-button" class="px-8 py-4 bg-cyan-500 text-black text-2xl rounded-lg hover:bg-cyan-400 transition-colors shadow-lg">Start Game</button>
    </div>
    <div id="game-over-screen" class="absolute inset-0 flex-col items-center justify-center bg-black bg-opacity-80 text-center" style="display: none;">
        <h1 class="text-6xl md:text-7xl mb-4 text-red-500">GAME OVER</h1>
        <p id="final-score" class="text-3xl mb-8"></p>
        <button id="restart-button" class="px-8 py-4 bg-cyan-500 text-black text-2xl rounded-lg hover:bg-cyan-400 transition-colors shadow-lg">Try Again</button>
    </div>
</div>

<script>
    // --- Basic Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const speedEl = document.getElementById('speed');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');
    const startButton = document.getElementById('start-button');
    const restartButton = document.getElementById('restart-button');
    const touchControls = document.getElementById('touch-controls');

    let game;

    // --- Game Class ---
    class Game {
        constructor(width, height) {
            this.width = width;
            this.height = height;
            this.gameState = 'START'; // START, PLAY, GAME_OVER
            this.keys = {};
            
            this.init();
            this.setupControls();
        }
        
        init() {
            this.player = new Player(this);
            this.tunnel = new Tunnel(this);
            this.stars = new Stars(this, 200);
            this.speed = 4;
            this.score = 0;
            this.lastTime = 0;
            this.scoreTimer = 0;
        }

        setupControls() {
            // Keyboard controls
            window.addEventListener('keydown', (e) => this.keys[e.key.toLowerCase()] = true);
            window.addEventListener('keyup', (e) => this.keys[e.key.toLowerCase()] = false);

            // Touch controls
            if ('ontouchstart' in window) {
                touchControls.style.display = 'block';

                const touchButtonMap = {
                    'touch-up': 'arrowup',
                    'touch-down': 'arrowdown',
                    'touch-left': 'arrowleft',
                    'touch-right': 'arrowright'
                };

                for (const [id, key] of Object.entries(touchButtonMap)) {
                    const button = document.getElementById(id);
                    button.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.keys[key] = true;
                    });
                    button.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.keys[key] = false;
                    });
                }
            }
        }

        start() {
            this.gameState = 'PLAY';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            this.init(); // Reset everything for a new game
            this.lastTime = performance.now();
            requestAnimationFrame(this.loop.bind(this));
        }
        
        endGame() {
            this.gameState = 'GAME_OVER';
            finalScoreEl.textContent = `FINAL SCORE: ${Math.floor(this.score)}`;
            gameOverScreen.style.display = 'flex';
        }

        loop(currentTime) {
            if (this.gameState !== 'PLAY') return;

            const deltaTime = (currentTime - this.lastTime) / 1000;
            this.lastTime = currentTime;

            this.update(deltaTime);
            this.draw();
            
            requestAnimationFrame(this.loop.bind(this));
        }

        update(deltaTime) {
            // Increase speed and score over time
            this.scoreTimer += deltaTime;
            if (this.scoreTimer > 0.1) { // Update score 10 times a second
                this.score += this.speed;
                this.scoreTimer = 0;
            }
            this.speed += deltaTime * 0.1; // Gradually increase speed

            this.stars.update();
            this.player.update(deltaTime);
            this.tunnel.update();
            
            if (this.tunnel.checkCollision(this.player)) {
                this.endGame();
            }
        }

        draw() {
            ctx.clearRect(0, 0, this.width, this.height);
            this.stars.draw();
            this.tunnel.draw();
            this.player.draw();
            this.updateUI();
        }

        updateUI() {
            scoreEl.textContent = `SCORE: ${Math.floor(this.score)}`;
            speedEl.textContent = `SPEED: ${this.speed.toFixed(1)}`;
        }
    }

    // --- Player Class ---
    class Player {
        constructor(game) {
            this.game = game;
            this.width = 40;
            this.height = 20;
            this.x = this.game.width * 0.15;
            this.y = this.game.height / 2;
            this.moveSpeed = 350;
        }

        update(deltaTime) {
            let dx = 0;
            let dy = 0;
            const keys = this.game.keys;
            
            if (keys['arrowup'] || keys['w']) dy = -1;
            if (keys['arrowdown'] || keys['s']) dy = 1;
            if (keys['arrowleft'] || keys['a']) dx = -1;
            if (keys['arrowright'] || keys['d']) dx = 1;
            
            this.x += dx * this.moveSpeed * deltaTime;
            this.y += dy * this.moveSpeed * deltaTime;

            // Bounds checking
            this.x = Math.max(0, Math.min(this.x, this.game.width - this.width));
            this.y = Math.max(0, Math.min(this.y, this.game.height - this.height));
        }

        draw() {
            ctx.fillStyle = '#00ffff'; // Cyan
            ctx.beginPath();
            ctx.moveTo(this.x + this.width, this.y + this.height / 2); // Nose
            ctx.lineTo(this.x, this.y); // Top-back
            ctx.lineTo(this.x + 5, this.y + this.height / 2); // Middle-back
            ctx.lineTo(this.x, this.y + this.height); // Bottom-back
            ctx.closePath();
            ctx.fill();
            
            // Cockpit
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(this.x + this.width * 0.6, this.y + this.height/2 - 2, 5, 4);
        }
    }

    // --- Tunnel Class ---
    class Tunnel {
        constructor(game) {
            this.game = game;
            this.segmentWidth = 50;
            this.segments = [];
            this.minGap = this.game.player.height + 80; // Increased min gap for playability
            this.maxGap = this.game.height * 0.6;
            
            // Initialize the tunnel segments to fill the screen
            let currentX = 0;
            while(currentX < this.game.width + this.segmentWidth) {
                this.generateSegment(currentX);
                currentX += this.segmentWidth;
            }
        }

        generateSegment(xPos) {
            const lastSegment = this.segments[this.segments.length - 1];
            let gapCenter = lastSegment ? lastSegment.gapCenter : this.game.height / 2;
            let gapHeight = lastSegment ? lastSegment.gapHeight : this.maxGap;

            // Randomly adjust the center and height for the new segment
            gapCenter += (Math.random() - 0.5) * 60;
            gapHeight += (Math.random() - 0.5) * 40;

            // Clamp values to be within bounds
            gapCenter = Math.max(this.maxGap / 2, Math.min(gapCenter, this.game.height - this.maxGap / 2));
            gapHeight = Math.max(this.minGap, Math.min(gapHeight, this.maxGap));
            
            const topHeight = gapCenter - gapHeight / 2;
            const bottomY = gapCenter + gapHeight / 2;
            
            this.segments.push({
                x: xPos,
                topHeight: topHeight,
                bottomY: bottomY,
                gapCenter: gapCenter,
                gapHeight: gapHeight
            });
        }

        update() {
            // Move all segments to the left
            this.segments.forEach(seg => {
                seg.x -= this.game.speed;
            });

            // Remove segments that are off-screen and add new ones
            while (this.segments.length > 0 && this.segments[0].x < -this.segmentWidth) {
                this.segments.shift();
                const lastX = this.segments[this.segments.length - 1].x;
                this.generateSegment(lastX + this.segmentWidth);
            }
        }
        
        checkCollision(player) {
            for (const seg of this.segments) {
                // Check for collision only with segments the player is currently inside
                if (player.x + player.width > seg.x && player.x < seg.x + this.segmentWidth) {
                    if (player.y < seg.topHeight || player.y + player.height > seg.bottomY) {
                        return true; // Collision detected
                    }
                }
            }
            return false;
        }

        draw() {
            ctx.fillStyle = '#008080'; // Teal color for the tunnel walls
            for (let i = 0; i < this.segments.length; i++) {
                const seg = this.segments[i];
                // Draw top part
                ctx.fillRect(seg.x, 0, this.segmentWidth + 1, seg.topHeight); // +1 to avoid gaps
                // Draw bottom part
                ctx.fillRect(seg.x, seg.bottomY, this.segmentWidth + 1, this.game.height - seg.bottomY);
            }
        }
    }

    // --- Stars Class for background effect ---
    class Stars {
        constructor(game, count) {
            this.game = game;
            this.count = count;
            this.stars = [];
            for (let i = 0; i < this.count; i++) {
                this.stars.push({
                    x: Math.random() * this.game.width,
                    y: Math.random() * this.game.height,
                    radius: Math.random() * 1.5,
                    speed: Math.random() * 0.5 + 0.25 // Slower than the tunnel
                });
            }
        }

        update() {
            this.stars.forEach(star => {
                star.x -= star.speed * this.game.speed * 0.5; // Move stars based on game speed
                if (star.x < 0) {
                    star.x = this.game.width;
                    star.y = Math.random() * this.game.height;
                }
            });
        }

        draw() {
            ctx.fillStyle = '#FFFFFF';
            this.stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }

    // --- Initialization ---
    function resizeCanvas() {
        const aspectRatio = 1200 / 800;
        let newWidth = window.innerWidth * 0.95;
        let newHeight = newWidth / aspectRatio;

        if (newHeight > window.innerHeight * 0.95) {
            newHeight = window.innerHeight * 0.95;
            newWidth = newHeight * aspectRatio;
        }
        
        canvas.width = 1200; // Fixed internal resolution
        canvas.height = 800;
        canvas.style.width = `${newWidth}px`;
        canvas.style.height = `${newHeight}px`;

        if (game) {
            game.draw(); // Redraw on resize if game exists
        }
    }

    window.addEventListener('resize', resizeCanvas);
    
    startButton.addEventListener('click', () => {
        if (!game) {
            game = new Game(canvas.width, canvas.height);
        }
        game.start();
    });
    
    restartButton.addEventListener('click', () => {
        game.start();
    });

    resizeCanvas();

</script>

</body>
</html>
